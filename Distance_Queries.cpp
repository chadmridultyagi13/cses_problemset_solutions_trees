    // jai shree krishna
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠙⠒⠦⢄⣀⠀⠀⠀⠈⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣉⣁⡒⠒⠢⠤⢄⣀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠶⣄⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠶⠛⠉⠀⣀⣤⠈⢹⠆⠀⠀⠀⠀⠉⠓⠲⢤⣀⠀⠀⠀⠀⠀⠈⠙⢦⡀⠀⠈⢣⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⣴⠟⢁⡤⡾⢠⠞⠁⠘⠒⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠲⢤⡀⠀⠀⠀⠀⠙⣆⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⢀⡾⢡⡴⠋⢰⠃⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⣄⡀⠀⠀⠈⢧⡀⠸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⣾⢁⡟⠀⠀⠸⡄⢸⠀⢀⡠⣤⠤⠤⠤⠤⠤⢤⣤⣄⣀⣀⠀⠀⠀⠀⠀⠀⠈⠙⣦⡀⠀⠀⢧⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⡏⢸⠀⠀⠀⠀⡇⢸⡶⠉⠀⠈⣧⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠓⠶⢦⣄⡔⠉⢰⠈⠳⡄⠀⠘⣇⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⣷⠈⢧⡀⠀⣠⠇⣼⢧⣄⡀⠐⣧⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣾⣿⢶⡞⠀⠀⢹⡆⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠘⣷⣄⣉⣉⣥⣞⡁⠀⠀⠙⠒⠛⠻⠿⢿⣶⣶⣶⣶⣶⣷⠿⠿⠛⠋⠁⠀⠀⠹⡆⠀⠀⢳⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⢀⡏⠀⠀⠙⡉⠀⠉⢿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡄⠀⢸⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠘⣷⣄⣀⣴⠁⠀⢤⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⡀⠀⠀⠀⠀⠀⢀⣠⡴⢷⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⢸⣹⠊⠁⠀⠀⣸⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠹⡄⠀⠀⢀⡴⠟⠁⠀⠘⣷⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠹⣷⣄⣤⣴⠿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⢱⠀⡴⠋⠀⠀⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⣦⠀⠀⠀⠀⠀⠀⢻⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠒⣥⢰⠁⠀⠀⠀⢀⡴⢷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⢻⣧⠀⠀⠀⣶⣤⣾⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⠿⠿⠛⠋⠀⠀⠀⠁⠘⡄⠀⠀⠋⢁⣠⣿⣞⣟⠤⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠈⠻⣷⣶⣾⡿⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⢹⡏⠿⠛⠋⠸⡬⣷⡤⠤⠒⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠞⠁⢀⠤⠒⠋⠉⠉⠉⠂⣀⡀⠀⠀⠀⠀⠘⢦⠀⠀⠀⠀⠀⢻⣮⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⢀⣤⣶⡏⠁⠀⠀⠀⠀⠀⠀⠀⠳⣄⠀⠀⠀⠈⢷⣗⢕⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠫⣳⡲⣲⣾⢻⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⡀⠀⠀⢸⡷⣍⠁⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⣿⢾⡫⠄⠚⠁⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢄⡀⣀⣤⠤⠞⠁⠀⠀⠀⣿⣀⠉⠐⠒⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠘⡆⠀⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⡀⠀⠀⣿⣌⠳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠙⠶⣟⣞⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠒⣊⠔⢻⠁⠀⠀⣿⢾⡕⠱⡀⠀⠀⠀⠀⠀⢀⡤⣾⣿⣿⡆⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⣾⠁⠀⢹⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠴⣯⣖⣉⣀⠴⠃⠀⠀⢸⢿⡿⣷⡄⠃⠀⠀⢀⣠⡾⠟⠀⠙⣿⣟⠁⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠈⣿⣦⣀⣼⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠦⣫⡦⣉⠀⣠⡖⠋⠉⠀⣠⠴⠋⠀⢯⢆⢀⡀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠇⠀⠘⣨⡵⠋⠉⠁⣀⡴⠊⠁⠀⠀⠀⢸⢠⠳⠛
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⣀⡴⠛⠛⠁⢀⡤⠞⠁⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠲⠤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⡿⢾⠇⠀⢀⣤⠞⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠒⢲⡶⠦⠤⠴⠶⠖⢚⣿⠟⠉⠀⢀⣠⠖⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⢀⣠⠖⠛⠛⠀⣠⠴⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⣠⠴⠋⠀⠀⣀⡴⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠋⠁⠀⢀⡤⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠚⠁⠀⢀⣠⠞⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠞⠁⠀⢀⣠⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    #include <iostream>
    #include <iomanip>
    #include <cstdio>
    #include <cstdlib>
    #include <cmath>
    #include <cstring>
    #include <ctime>
    #include <cassert>
    #include <climits>
    #include <cfloat>
    #include <vector>
    #include <list>
    #include <deque>
    #include <queue>
    #include <stack>
    #include <map>
    #include <set>
    #include <bitset>
    #include <algorithm>
    #include <numeric>
    #include <utility>
    #include <functional>
    #include <sstream>
    #include <fstream>
    #include <random>
    #include <string>
    #include <iterator>
    #include <complex>
    #include <stdexcept>
    #include <memory>
    #include <new>
    #include <thread>
    #include <mutex>
    #include <future>
    #include <condition_variable>
    #include <tuple>
    #include <typeinfo>
    #include <limits>
    #include <array> 
    using namespace std;

    // Disjoint Set Union-Find
    class DisjointSet {
        vector<int> rank, parent, size; 
    public: 
        DisjointSet(int n) {
            rank.resize(n + 1, 0); 
            parent.resize(n + 1);
            size.resize(n + 1); 
            for(int i = 0; i <= n; i++) {
                parent[i] = i; 
                size[i] = 1; 
            }
        }

        int findUPar(int node) {
            if(node == parent[node])
                return node; 
            return parent[node] = findUPar(parent[node]); 
        }

        void unionByRank(int u, int v) {
            int ulp_u = findUPar(u); 
            int ulp_v = findUPar(v); 
            if(ulp_u == ulp_v) return; 
            if(rank[ulp_u] < rank[ulp_v]) {
                parent[ulp_u] = ulp_v; 
            } else if(rank[ulp_v] < rank[ulp_u]) {
                parent[ulp_v] = ulp_u; 
            } else {
                parent[ulp_v] = ulp_u; 
                rank[ulp_u]++; 
            }
        }

        void unionBySize(int u, int v) {
            int ulp_u = findUPar(u); 
            int ulp_v = findUPar(v); 
            if(ulp_u == ulp_v) return; 
            if(size[ulp_u] < size[ulp_v]) {
                parent[ulp_u] = ulp_v; 
                size[ulp_v] += size[ulp_u]; 
            } else {
                parent[ulp_v] = ulp_u;
                size[ulp_u] += size[ulp_v]; 
            }
        }
    }; 

    // Shortest Path using Dijkstra’s Algorithm
    vector<int> shortestPath(int n, int m, vector<vector<int> >& edges) {
        vector<vector<pair<int, int> > > adj(n + 1);
        for (size_t i = 0; i < edges.size(); i++) {
            adj[edges[i][0]].push_back(make_pair(edges[i][1], edges[i][2]));
            adj[edges[i][1]].push_back(make_pair(edges[i][0], edges[i][2]));
        }
        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > qt;
        vector<int> dist(n + 1, INT_MAX);
        dist[1] = 0;
        qt.push(make_pair(0, 1));
        vector<int> par(n + 1, INT_MAX);
        par[1] = -1;
        
        while (!qt.empty()) {
            int node = qt.top().second;
            int dis = qt.top().first;
            qt.pop();
            for (auto it : adj[node]) {
                if (it.second + dist[node] < dist[it.first]) {
                    par[it.first] = node;
                    dist[it.first] = it.second + dist[node];
                    qt.push(make_pair(dist[it.first], it.first));
                }
            }
        }
        
        vector<int> ans;
        if (par[n] == INT_MAX) {
            vector<int> result;
            result.push_back(-1);
            return result;
        }
        
        int i = n;
        while (par[i] != -1) {
            ans.push_back(i);
            i = par[i];
        }
        ans.push_back(1);
        reverse(ans.begin(), ans.end());
        return ans;
    }

    // Topological Sort (DFS)
    void dfs_topological(stack<int>& st, vector<int>& mark, vector<vector<int> >& adj, int node) {
        mark[node] = 1;
        for (auto it : adj[node]) {
            if (mark[it] == 0) {
                dfs_topological(st, mark, adj, it);
            }
        }
        st.push(node);
    }

    // Topological Sort
    vector<int> topologicalSort(vector<vector<int> >& adj) {
        stack<int> st;
        vector<int> mark(adj.size(), 0);
        for (size_t i = 0; i < adj.size(); i++) {
            if (mark[i] == 0) {
                dfs_topological(st, mark, adj, i);
            }
        }
        vector<int> ans;
        while (!st.empty()) {
            int y = st.top();
            st.pop();
            ans.push_back(y);
        }
        return ans;
    }

    // Main Function


    void fs(int node, int p, vector<vector<int> >&adj, vector<vector<int> >&up, vector<int>&tin, vector<int>&tout, int& timer,int &l) {
        tin[node] = timer++;
        up[node][0] = p; // parent of node
        for (int i = 1; i <= l; i++){
            if(up[node][i-1]!=-1){
                up[node][i] = up[up[node][i-1]][i-1]; // 2^i parent of node
            }
        }
        for (auto it : adj[node]) {
            if (it != p) {
                fs(it, node, adj, up, tin, tout, timer, l);
            }
        }
        tout[node] = timer++;
    }
    void height(vector<vector<int> >&adj, vector<int>&h, int node, int p) {
        for (auto it : adj[node]) {
            if (it != p) {
                h[it] = h[node] + 1;
                height(adj, h, it, node);
            }
        }
    }

    bool isAncestor(int u, int v, vector<int>&tin, vector<int>&tout) {
        return tin[u] <= tin[v] && tout[u] >= tout[v];
    }

    void f (vector<vector<int> >&adj, vector<int>&dis,int node , int p){
        for(auto it : adj[node]){
            if(it!=p){
                dis[it] = dis[node] + 1; 
                f(adj, dis, it, node); 
            }
        }
    }
        
    int main() {
        ios_base::sync_with_stdio(false); 
        cin.tie(NULL);
        int n ; cin>>n ; 
        int q ; cin>>q ; 
        vector<vector<int> >adj(n+1) ; 
        for(int i = 1 ; i <= n-1; i++){
            int a ; int b ; cin>>a>>b ;  
            adj[a].push_back(b) ; 
            adj[b].push_back(a) ; 
        }
        
        vector<int>tin(n+1,0) ; 
        vector<int>tout(n+1,0) ;
        vector<int>h(n+1,0) ;
        h[1] = 0 ; 
        height(adj, h, 1, -1) ;
        int l  = ceil(log2(*(max_element(h.begin(), h.end())))) ; 
        vector<vector<int> >up(n+1,vector<int>(l+1,-1)) ;  
        int p = -1  ; 
        fs(1, p, adj, up, tin, tout, p, l);

            vector<int> dis(n+1, 0);
            f(adj, dis, 1, -1);
        while(q--){
            int a ; int b ; 
            cin>>a>>b ;
            int lca = -1 ;
            if(isAncestor(a, b, tin, tout)){
                lca  = a ; 
            } else if(isAncestor(b, a, tin, tout)){
                lca = b ;
            }
            else{
            int u = a ; 
            for(int i = l ; i >=0 ; i--){
                if(u!=-1 && up[u][i]!=-1&&!isAncestor(up[u][i], b, tin, tout)){
                    u = up[u][i] ; 
                }
            }
            lca =  u ; }

            int ans = dis[a] + dis[b] - 2 * dis[lca];
            cout << ans << "\n";
    }}
